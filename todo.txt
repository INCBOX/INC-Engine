

	IMPROVE ENGINE GLOBALS.. OR GET RID OF IT?..
	
	
[MED] IGPUMesh forward declaration error in static_mesh_loader.cpp
    - WHY: Using incomplete type prevents method calls and unique_ptr usage.
    - ACTION: Include actual definition, not just forward declare.

[LOW] Clean up g_StarfieldMesh lifetime
    - WHY: Linker error due to undefined symbol.
    - ACTION: Define it in mesh_primitives.cpp, declare properly in a header.
	
	
	
	
Step 1: Procedural starfield + nebula background (shader).




---------------
1 Modular Precision System MATHLIB modular 
Next-Level: Optional precision layer macro
mathlib_precision.h
convert_utils.h

2 Double-Precision Camera System with floating-origin - Camera_f and Camera_d
Goal: Eliminate float precision errors when the player/camera is millions of units from origin.

	- Camera_d moves through real world (light-years, kilometers)
	- CameraManager computes offset from that
	- Camera_f is locked to (0,0,0) or local offset and used for gameplay
	- All rendering systems use CameraManager::GetWorldCamera() for global visuals, and CameraManager::GetLocalCamera() for gameplay visuals

CameraManager 
	Floating origin system
	Keep your local scene centered near 0,0,0, while rendering based on real planetary/starlight coordinates
	Starfield with true parallax

	A high-precision Camera_d for world
	A float Camera_f for gameplay
	- Player‚Äôs transform must use Vector3_d

IMPORTANT: need to sync camera_d ‚Üí camera_f

---------------

STEP 3 ‚Äì Procedural Starfield System
Once the camera works at double-precision:
Use Vector3_d for star positions (thousands to millions)
Stars only render if they're within camera culling bounds
You render them relative to camera origin, and feed float version to GPU
Use a point sprite shader, no geometry, millions of stars with zero overdraw
-------------

‚ú® STARFIELD ‚Äì Ongoing Improvements
- [ ] Add procedural 3D star layout (not just background)
- [ ] Implement parallax and camera-relative depth logic
- [ ] Physically accurate star brightness + distance falloff
- [ ] Support millions of stars with zero overdraw
- [ ] Optional: Depth layers (e.g., nebula behind star layer)

dynamic 3D stars with true parallax
physically accurate brightness falloff over light-years
procedural galaxy noise, color tinting, and depth layering
camera-relative rendering to eliminate float precision errors
millions of stars at zero performance cost
üöÄ Star Citizen‚ÄìStyle Starfield: Goals
You‚Äôre not looking for a bokeh blobfield ‚Äî you‚Äôre aiming for this:
Infinite starfield with real spatial layout
Zero overdraw & fast rendering, even with 10,000+ stars
Sharp, twinkling point stars
Parallax with camera movement
Depth sorting (optional: far nebula behind stars)





Step 2: Sector-based space chunking for object management.
Step 3: Procedural planets, dynamic props, etc.


üöÄ INC Planetary Engine ‚Äì High-Fidelity TODO List

‚úÖ PHASE 0 ‚Äì Foundations (already partially done)
- [x] Implement double-precision `Vector3_d` and `Matrix4x4_d`
- [x] Add camera-relative rendering system to eliminate float errors
- [x] Create working `GLStarfieldRenderer` API and render pass
- [x] Replace map‚Äôs static geometry with floating planets/spheres

ü™ê PHASE 1 ‚Äì Planet System Runtime Replacement
- [ ] Remove JSON-defined planets from level system
- [ ] Create `PlanetSystem` class to manage all planets
- [ ] Implement `Planet` class with:
  - [ ] `Vector3_d position`
  - [ ] `double radius`
  - [ ] `uint32_t seed`
  - [ ] Optional: biome or material parameters
- [ ] Create engine-side registration like:
  PlanetSystem::RegisterPlanet("earth", 6371.0, Vector3_d(1e6, 0, 0), 1234);


		Optional: Floating Origin Support (Star Citizen-style) well we probably want that.. baby 
		Your To-Do Breakdown:
		Task	Module	Status
		Double precision mathlib (Vector3_d, Matrix4x4_d)	mathlib	Done
		Refactor Camera to Camera_d	camera_d.h/.cpp	Needs rewrite
		Add world-space to render-space logic	RenderTransformSystem	Needs implementation
		Update render system to use float model matrices	PlanetRenderer, EntityRenderer	WIP
		Add streaming LOD based on camera.worldPosition	StreamingManager, PlanetLODSystem	Co
		
		üêâ The Dragon: Parented Transforms
		If you want characters moving inside ships (that move through space), you‚Äôll have to support:
		local transforms (float, relative to parent)
		world transforms (double, absolute in space)
		Proper update chains: parent rebasing updates children
		You ready for that? Or should we just glue everyone to asteroids and pretend ships don‚Äôt move?








üåç PHASE 2 ‚Äì Planet Rendering and LOD System
- [ ] Create basic `PlanetRenderer` class (one per planet)
- [ ] Use UV sphere mesh or cube-sphere for test planet
- [ ] Implement `PlanetLODNode` with:
  - [ ] Frustum culling
  - [ ] Distance-based LOD switching
  - [ ] Chunk generation requests
- [ ] Begin `PlanetChunk` system with LOD mesh generation

üåÑ PHASE 3 ‚Äì Terrain Generation System
- [ ] Create terrain generator backend:
  - [ ] Perlin or Simplex noise-based height generation
  - [ ] Optional: heightmap support
- [ ] Patch-level procedural generation tied to `PlanetChunk`
- [ ] Implement async terrain generation jobs (threaded)

üåå PHASE 4 ‚Äì Visuals & Physics Integration
- [ ] Add realistic lighting and shading to terrain patches
- [ ] Add atmosphere rendering (optional)
- [ ] Add planetary gravity wells that affect players and entities
- [ ] Link physics to planetary surface for walking/flying
- [ ] Handle collision + landing on planets


üß† FUTURE (after planetary system is stable)
- [ ] Galaxy map & fast travel
- [ ] Surface biome blending system
- [ ] Landing zones and surface POIs
- [ ] Dynamic weather on planets
- [ ] Atmospheric entry VFX








üöÄ High-Fidelity Simulation (what Star Citizen uses)
This is what you‚Äôre trying to move toward:

Feature	Description
Procedural + data-driven	Planets are defined by seeds, materials, atmospheres, gravity ‚Äî not just geometry
Origin shifting / camera-relative	Keeps precision high by offsetting world instead of camera
LOD terrain streaming	Patches load in chunks as player approaches
Patch-based simulation	Surface sim, physics, weather are all done per-tile
Massive scale	1:1 scale planets, moons, stations
Example	Star Citizen, Outerra, Elite Dangerous

üéØ What Star Citizen Actually Uses
Proprietary binary formats (.zone, .entity, etc.)

Procedural terrain with runtime LOD generation

Planet definitions via parameterized assets (like planet_data.xml, not JSON geometry)

Each planet: procedural seed, radius, material layers, gravity, atmosphere params

Level editor is only used for space stations or interiors ‚Äî not planetary layout

